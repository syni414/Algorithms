package tp1;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.Scanner;
import java.util.Random;
import java.util.LinkedList;
import java.util.List;


public class TriFusionVar {

	public static void main(String[] args) {
		/**compare complexity of 4 variants of merge sort*/	
		
		//donne la taille des donnees
		Scanner scan = new Scanner(System.in);
		int n = 0;
		System.out.println("donner la taille n du tableau/liste");
		if(scan.hasNextInt()) {
			n = scan.nextInt();
		}
		System.out.println(n);
		
		//creation du premier tableau avec des entiers al√©atoires de 1-100
		Random random = new Random();
		Integer[] tableau1 = new Integer[n];
		for(int i = 0; i<n; i++) {
			tableau1[i] = random.nextInt(100);
		}
		
		//clone tableau
		Integer[] tableau2 = cloneTable(tableau1);
		
		//clone listes		
		ArrayList<Integer> liste1 = cloneListe(tableau1);
		ArrayList<Integer> liste2 = cloneListe(tableau1);
		
		//tri par variante

		//affichage du tableau

		afficheTab(tableau1);
		afficheListe(liste1);
		afficheListe(liste2);
		
		sortListCopy(liste1);
		afficheListe(liste1);
		
		sortTabCopy(tableau1);
		afficheTab(tableau1);
		
		sortTabNoCopy(tableau2);
		afficheTab(tableau2);
		scan.close();
	}
	
	
	
	//procedure copie tableau -> tableau
	public static Integer[] cloneTable(Integer []source) {
		Integer[] tableau2 = new Integer[source.length];
		for(int i = 0; i<source.length; i++) {
			tableau2[i] = source[i];
		}
		return tableau2;
	}
	
	//procedure copie tableau -> Liste
	public static ArrayList<Integer> cloneListe(Integer []source) {
		ArrayList<Integer> liste1 = new ArrayList<Integer>();
		for(Integer val: source) {
			liste1.add(val);
		}
		return liste1;
	}

	//affiche tous les elements d'un tableau
	public static void afficheTab(Integer []source) {
		for(int i = 0; i<source.length; i++) {
			System.out.print(source[i] + " ");
		}
		System.out.println();
	}
	
	//affiche tous les elements d'une liste
	public static void afficheListe(ArrayList<Integer> desElements) {
		Iterator<Integer> iteTab1 = desElements.iterator();
		while(iteTab1.hasNext()) {
			System.out.print( iteTab1.next() + " ");
		}
		System.out.println();
	}
		
	//Variante 1: Tri tableau avec copie
	public static void sortTabCopy(Integer []source) {
		sortRecTab(source, 0, source.length-1);
	}
		
	//Variante 2: Tri tableau sans copie
	public static void sortTabNoCopy(Integer []source) {
		int len = 1;
	    
	    while (source.length > len) {
	        
	        for (int i = 0; i + len <= source.length - 1; i += len * 2) {
	            int left = i;
	            int mid = i + len - 1;
	            int right = i + len * 2 - 1;
	            
	            if (right > source.length - 1)
	                right = source.length - 1;

	            mergeTab(source, left, mid, right);
	        }
	       
	        len *= 2;
	    }

	}	
	
	//Variante 3: Tri liste avec copie
	public static void sortListCopy(ArrayList<Integer> source) {
		sortRecList(source, 0, source.size()-1);
	}	
/*
	//Variante 4: Tri liste sans copie
	public static void SortListNoCopy(ArrayList<Integer> source) {
			}	*/
	
	
	//tri fusion table: on separe le tableau
	public static void sortRecTab(Integer []source, int inf, int sup) {
		if(inf >= sup) 
			return;
		
		int mid = (inf + sup)/2;
		
		sortRecTab(source, inf, mid);
		sortRecTab(source, mid+1, sup);
		mergeTab(source, inf, mid, sup);		
	}
	
	//tri fusion table: on reunit les tableaux
	public static void mergeTab(Integer []source, int inf,int mid, int sup) {
		Integer []temp = new Integer[sup-inf+1];
		int itLeft = inf;
		int itRight = mid+1;
		int itCopy = inf;
		int itTemp = 0;
		
		while(itLeft <= mid && itRight <= sup) {
			if( source[itLeft].compareTo(source[itRight]) <= 0 ) {
				temp[itTemp] = source[itLeft];
				itLeft++;
			}else {
				temp[itTemp] = source[itRight];
				itRight++;
			}
			itTemp++;
		}
		
		while(itLeft <= mid) {
			temp[itTemp] = source[itLeft];
			itLeft++;
			itTemp++;
		}
		
		while(itRight <= sup) {
			temp[itTemp] = source[itRight];
			itRight++;
			itTemp++;
		}
		
		for(int i = 0; i <= temp.length-1; i++) {
			source[itCopy] = temp[i];
			itCopy++;
		}		
	}	
	
	//tri fusion liste: on separe la liste
	public static void sortRecList(ArrayList<Integer> source, int inf, int sup) {
		if(inf >= sup) 
			return;
		
		int mid = (inf + sup)/2;
		
		sortRecList(source, inf, mid);
		sortRecList(source, mid+1, sup);
		mergeList(source, inf, mid, sup);
	}
	
	//tri fusion liste: on reunit les listes
	public static void mergeList(ArrayList<Integer> source, int inf,int mid, int sup) {
		ArrayList<Integer> temp = new ArrayList<>();
		int itLeft = inf;
		int itRight = mid+1;
		int itCopy = inf;
		
		while(itLeft <= mid && itRight <= sup) {
			if( source.get(itLeft).compareTo(source.get(itRight)) <= 0 ) {
				temp.add(source.get(itLeft));
				itLeft++;
			}else {
				temp.add(source.get(itRight));
				itRight++;
			}
		}
		
		while(itLeft <= mid) {
			temp.add(source.get(itLeft));
			itLeft++;
		}
		
		while(itRight <= sup) {
			temp.add(source.get(itRight));
			itRight++;
		}
		
		for(int i = 0; i<= temp.size()-1; i++) {
			source.set(itCopy, temp.get(i));
			itCopy++;
		}
	}
}


